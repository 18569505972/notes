# 引用类型

## Object

建立对象有两种方法 ，使用new Object()或者是使用{}字面量写法

```javascript
var person1 = new Object();
person1.name = "p1";

var person2 = {};
person2.name = "p2"

var person3 = { name:"p3",0:"test"};
//上述这三种没有什么区别
console.info(person1.name); // p1
console.info(person2["name"]); // p2
console.info(person3[0]); // test -- 数字也可以作为属性名的
```



## Array

+ 数组声明

  ```javascript
  var colors = new Array(3);
  var names = new Array("Greg","John");
  var nums = [1,2,3,4,5];

  nums[nums.length] = 6; //在位置6 再添加数字6
  ```

  栈堆操作，shift和unshift是对数组列头部进行推出和推入操作。pop和push是对尾部进行推出和推入操作

+ 数组的栈堆方式

  栈堆操作，shift和unshift是对数组列头部进行推出和推入操作。pop和push是对尾部进行推出和推入操作

  ```javascript
  var nums = ['0','1','2'];
  nums.unshift("3","4"); // 5 -- shift方法会返回当前数组长度
  nums.toString(); // "3,4,0,1,2"
  nums.shift(); // "3" -- unshift方法会返回推出的数组的数据
  nums.toString(); // "4,0,1,2"
  nums.push("5","6"); // 6 -- push 方法和shift方法一样，会返回数组长度
  nums.toString();// "4,0,1,2,5,6"
  nums.pop(); // "6" -- 和unshift一样会返回推出数组的数据
  nums.toString(); //"4,0,1,2,5"
  ```

+ 数组的排序

  数组排序操作，使用sort()方法,默认是将数组内的数据全部转化为string来比较大小。所以对number类型数据的数组，直接使用sort()方法并不能进行有效排序。reverse()方法仅仅只是用来让数组顺序颠倒而已

  ```javascript
  var nums = [0,5,1,10,15];
  nums.sort(); //[0, 1, 10, 15, 5]
  /*
  	结果为："0,1,10,15,5"
  	因为ascii码问题，数字转为字符串再转为ascii比较
      "5" -- 53
      "10" -- 分解为 '1','0',首字符"1":49
      所以"5">"10"
  */
  nums.reverse();//[5, 15, 10, 1, 0]  -- 仅仅只是翻转数组而已
  ```

  针对上述问题，sort()可以自定义对比函数当做参数穿入实现自定义排序。自定义 方法要返回0,-1,1来区别相等，小于，大于

  ```javascript
  function compare(value1,value2){
      if(value1 > value2){
          return 1;
      }else if(value1 == value2){
  		return 0        
      }else{
        	return -1;
      }
  }
  var nums = [0,5,1,10,15];
  nums.sort(compare); //[0, 1, 10, 15, 5]
  nums.reverse();//[15, 10, 5, 1, 0] -- 如果只是反转数组的话，使用reverse()比使用sort()配合相反的compare()更快
  ```

+ 数组的其他操作

  1. concat()合并数组并添加在尾部，返回合并后的新的数组，不会改变原有数组。

     ```javascript
     var colors = ["red", "green", "blue"];
     var colors2 = colors.concat("yellow", ["black", "brown"]);
     colors.toString(); //"red,green,blue"
     colors2.toString(); //"red,green,blue,yellow,black,brown"
     ```

  2. slice()截断头尾部分，返回全新的数组

     ```javascript
     var colors = ["red", "green", "blue", "yellow", "purple"];
     var colors2 = colors. slice(1);
     var colors3 = colors. slice(2, 3);
     colors.toString(); //"red,green,blue,yellow,purple"
     colors2.toString(); //"green,blue,yellow,purple"
     colors3.toString(); //"blue"
     ```

  3. splice()删除，插入，替换

     ```javascript
     var nums = [0,1,2,3,4,5,6,7,8];
     //splice(start,end); 删除从开始到结束的部分内容
     nums.splice(0,2); //[0, 1] -- 返回被删除的部分
     nums.toString(); //"2,3,4,5,6,7,8"

     //splice(index,0,arg1,arg2...); 从index位置开始插入arg1,arg2....
     nums.splice(2,0,11,12); //[] -- 插入操作返回空数组,因为第二个参数为0,没有截取长度
     nums.toString(); //"2,3,11,12,4,5,6,7,8"

     //splice(start,end,arg1,arg2...); 替换，其实就是删除插入啦....
     nums.splice(3,3,33,22); //[12, 4, 5]
     nums.toString();//"2,3,11,33,22,6,7,8"

     ```

  4. indexOf()和lastIndexOf()

     查找某个数在数组中的位置。略

  5. every()与some()迭代

     对于every()数组中每一项数给定一个函数。如果函数对每一项都返回true，则返回true

     对于some()恰好反过来了,只要有一项为true，则返回true

     （这两个函数对于部分校验非常好用）

     > 参数依次均为：item,index,array

     ```javascript
     var nums = [2,3,4,6,8,10];
     function isEven(num,index,array){
         if(num % 2 ==0){
             return true;
         }
     }
     nums.every(isEven); //false;
     nums.some(isEven); //true

     nums.splice(1,1); //[3] 删除第二项3
     //再次执行相同every
     nums.every(isEven); //true;
     ```

  6. filter()迭代每一项数，如果给定函数返回true则保留,返回false则剔除。返回一个全新的数组，源数据不变

     > 参数依次为item,index,array

     ```javascript
     var nums = [2,3,4,6,8,10];
     function isEven(num,index,array){
         if(num % 2 ==0){
             return true;
         }
     }
     nums.filter(isEven);//[2, 4, 6, 8, 10] -- 返回一个全新数组
     nums.toString();//"2,3,4,6,8,10" -- 原来数据不变
     ```

  7. map() 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值,方法按照原始数组元素顺序依次处理元素。

     > 参数依次为item,index,array

     ```javascript
     var nums = [2,3,4,6,8,10];
     function dblNum(num,index,array){
         return num*2;
     }
     nums.map(dblNum); //[4, 6, 8, 12, 16, 20] -- 返回处理后的值的数组
     nums.toString(); //"2,3,4,6,8,10" -- 源数据不变
     ```

  8. forEach() 就是单纯的迭代遍历操作

     ```javascript
     var nums = [2,3,4,6,8,10];
     nums.forEach(function (item,index,array){
         //此处执行某些操作
     });
     ```

  9. reduce()和reduceRight()

     reduce()是迭代合并方法。将上一个计算结果的值返回给下一次迭代进行计算

     reduceRight()只是执行方向反了而已，它们完全相同

     ```javascript
     var nums = [2,3,4,6,8,10];
     nums.reduce(function(prev,cur,index,array){
         return prev+cur; //计算合计
     }); //33 -- 2+3+4+6+8+10
     ```

     ​

## Date

日期类型。构造函数不带参的情况下默认为当前时间。如果想指定日期和时间，则必须穿入毫秒数（即Unix时间戳）

```javascript
var current = new Date(); //声明当前时间
var other = new Date(1504597302000); //声明其他指定时间

//另外还提供了Date.parse(),Date.UTC()两个方法将日期字符串转为毫秒数不过Date.parse()一般适用性不好，不提倡使用。
/*
	Date.UTC参数依次是[年][月(0-11)][日][时(24小时制)][分][秒][毫秒]
	不过Date.UTC()时间没有时差的。在中国的话就是还得再减8个小时才是正常时间
*/
var tmp = Date.UTC(2005,3,17,(15-8),55,55); //1113724555000 -- 减8小时才是才是指定的东八区时间
var dt = new Date(tmp); //2005-04-17 15:55:55
```

> 协调世界时（英：**C**oordinated **U**niversal **T**ime ，法：**T**emps **U**niversel **C**oordonné），又称世界统一时间，世界标准时间，国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。
>
> ​												 -- 摘自百度百科

toString();valueOf();

```javascript
var dt = new Date(1113724555000);
dt.toString(); //"Sun Apr 17 2005 15:55:55 GMT+0800 (中国标准时间)"

dt.valueOf(); //1113724555000
```

日期的格式化

+ toLocaleString();
+ toDateString();
+ toGMTString();
+ toUTCString();

下面以chrome为例

```javascript
var dt = new Date(1113724555000);
dt.toLocaleString(); //"2005/4/17 下午3:55:55"
dt.toDateString(); //"Sun Apr 17 2005"
dt.toGMTString(); //"Sun, 17 Apr 2005 07:55:55 GMT" 与 toUTCString方法等价
dt.toUTCString(); //"Sun, 17 Apr 2005 07:55:55 GMT"
```

日期/时间组件

```javascript
//以下日期函数以此为前提
var dt = new Date(1113744555000); //初始日期为 2005-04-17 21:29:15 GMT+8

dt.getTime(); //1113744555000
dt.setTime(1113748155000); //1113748155000 -- 设置日期为 2005-04-17 22:29:15 GMT+8
dt.getFullYear(); //2005
dt.getUTCFullYear(); //2005
dt.setFullYear(2008); //1208442555000 -- 设置年份为 2008年
dt.setUTCFullYear(2008); //1208442555000 -- 设置UTC年份为2008年
dt.getMonth(); //3 -- 月份从0开始计数的
dt.getUTCMonth(); //3 -- UTC月份从0开始计数的
dt.setMonth(5);//1213712955000 -- 设置日期为6月
dt.setUTCMonth(5);//1213712955000 -- 设置为UTC时间6月
dt.getDate(); //17 -- 返回当前是某月几日
dt.getUTCDate(); //17 -- 返回是UTC的某月几日
dt.setDate(31); //1214922555000 -- 因为6月没有31日，所以设置日期成为2008-07-01 22:29:15 GMT+8
dt.setUTCDate(31);//1217514555000 -- 设置UTC时间，当前日期为2008-07-31 22:29:15 GMT+8
dt.getDay(); //4 -- 返回星期几，0表示星期日，6表示星期六（当前为星期四）
dt.getUTCDay(); //4 -- 返回UTC日期的星期几
dt.getHours(); //22 -- 返回小时数（0-23，24:00实则为0:00）
dt.getUTCHours(); //14 -- 返回UTC日期的小时数
dt.setHours(21);//1217510955000 -- 设置小时数超过则增加天数，当前日期为为2008-7-31 21:29:15 GMT+8
dt.setUTCHours(15); //1217518155000 -- 设置为UTC的小时数超过则增加天数，当前日期为2008-7-31 23:29:15 GMT+8
dt.getMinutes(); //29 -- 返回分钟数（0-59）
dt.getUTCMinutes(); //29 -- 赶回UTC日期的分钟数
dt.setMinutes(125); //1217523915000 --设置分钟数，超过则增加小时数，当前时间为2008-8-1 01:05:15 GMT+8
dt.setUTCMinutes(32); //1217523615000 -- 设置分钟数，超过则增加小时数，当前时间为2008-8-1 01:00:15 GMT+8
/*
懒了，还有以下这些方法不说了
getSeconds();
setSeconds(秒);
getUTCSeconds();
setUTCSeconds(秒);
getMilliseconds();
setMilliseconds(毫秒);
getUTCMilliseconds();
setUTCMilliseconds(毫秒);
*/
dt.getTimezoneOffset(); //-480 -- 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化
```



## RegExp

ECMAScript是通过RegExp类型来支持正则表达式的。

```javascript
//使用Prel的语法可以创建一个正则表达式
var expression = /pattern/flags;
```

